{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-06-27T06:02:15.000Z","updated":"2021-06-27T06:44:30.897Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"纪念日","slug":"the first & twelfth","date":"2021-07-21T16:11:59.000Z","updated":"2021-07-21T17:50:34.141Z","comments":true,"path":"2021/07/22/the first & twelfth/","link":"","permalink":"http://example.com/2021/07/22/the%20first%20&%20twelfth/","excerpt":"the first &amp; twelfth 见到她的第一眼，她就露出了像花儿一样的笑容，眼睛弯成一道月亮的形状 我不知道她是笑什么，我只是觉得很美妙，在那一瞬间我好像接收到了生命的旨意：这个人很不一样，我应该要认真对待 虽然是第一次见面，但是彼此都出乎意料的健谈，完全不像是第一次见面的陌生人，虽然谈论的话题并不深刻，但是恰恰是日常生活的交流让我感觉到我们好像在很久之前就应该认识了，这一次更像是久别重逢 吃完饭我不知道该怎么继续，她说要回家去见她朋友，我俩上了地铁，到站她说要走了，我也默默挥手（锤爆自己），今天她还在说这件事😂，但其实我也实在想不起来彼时彼刻我在想什么，我只记得那天吃完饭我格外平静，就是有些简单的喜悦，现在想起还是微微扬起嘴角的那种喜悦，可能是情绪抑制了我的思考，我没能送她回家 今天是我们的第二次见面，我计划有一些话要跟她当面说（我打算跟他摊牌了，我希望她能清楚感受到我的想法，我也抑制不了这种表达的冲动） 但是话到嘴边却有些难以开口，直到最后太晚她不得不回家了，我终于大概是语无伦次的向她告白，我告诉她我喜欢她，并询问她的想法，我想象中她也会热烈的给予我肯定的回答，甚至还会给我一个大大的拥抱😁 然而我并没有得到期待的回应，她告诉我我的节奏有些快了，彼此应该再多互相了解，那一刻我是紧张且失落的，虽然她表达了继续接触的意愿，但是我怎么可能只是想和她继续接触这么简单！！ 我脑子里只有一个念头，就是要确切的知道他是不是喜欢我，准确的说应该是是不是不喜欢我！！！。。。？？？真是要命 后面她的话我都有些听不进去了，我不知道是不是错觉突然我好像又感觉到她其实也是有感觉的，只是实在有些太快了，她接受不了，毕竟到今天我们也才认识12天而已，于是我重新找回了一点自信，我需要让她感受到我的真诚，我反复告诉她我绝对不是因为想结婚了才跟她交往，我是真的喜欢她，请他一定相信我！！！ 结束谈话我的心情久久不能平静，我能理解她的想法也尊重她的想法，我想我现在应该做的就是继续保持全力在追求的路上奔驰，直到我们都期待的那一天，真的来临！","text":"the first &amp; twelfth 见到她的第一眼，她就露出了像花儿一样的笑容，眼睛弯成一道月亮的形状 我不知道她是笑什么，我只是觉得很美妙，在那一瞬间我好像接收到了生命的旨意：这个人很不一样，我应该要认真对待 虽然是第一次见面，但是彼此都出乎意料的健谈，完全不像是第一次见面的陌生人，虽然谈论的话题并不深刻，但是恰恰是日常生活的交流让我感觉到我们好像在很久之前就应该认识了，这一次更像是久别重逢 吃完饭我不知道该怎么继续，她说要回家去见她朋友，我俩上了地铁，到站她说要走了，我也默默挥手（锤爆自己），今天她还在说这件事😂，但其实我也实在想不起来彼时彼刻我在想什么，我只记得那天吃完饭我格外平静，就是有些简单的喜悦，现在想起还是微微扬起嘴角的那种喜悦，可能是情绪抑制了我的思考，我没能送她回家 今天是我们的第二次见面，我计划有一些话要跟她当面说（我打算跟他摊牌了，我希望她能清楚感受到我的想法，我也抑制不了这种表达的冲动） 但是话到嘴边却有些难以开口，直到最后太晚她不得不回家了，我终于大概是语无伦次的向她告白，我告诉她我喜欢她，并询问她的想法，我想象中她也会热烈的给予我肯定的回答，甚至还会给我一个大大的拥抱😁 然而我并没有得到期待的回应，她告诉我我的节奏有些快了，彼此应该再多互相了解，那一刻我是紧张且失落的，虽然她表达了继续接触的意愿，但是我怎么可能只是想和她继续接触这么简单！！ 我脑子里只有一个念头，就是要确切的知道他是不是喜欢我，准确的说应该是是不是不喜欢我！！！。。。？？？真是要命 后面她的话我都有些听不进去了，我不知道是不是错觉突然我好像又感觉到她其实也是有感觉的，只是实在有些太快了，她接受不了，毕竟到今天我们也才认识12天而已，于是我重新找回了一点自信，我需要让她感受到我的真诚，我反复告诉她我绝对不是因为想结婚了才跟她交往，我是真的喜欢她，请他一定相信我！！！ 结束谈话我的心情久久不能平静，我能理解她的想法也尊重她的想法，我想我现在应该做的就是继续保持全力在追求的路上奔驰，直到我们都期待的那一天，真的来临！","categories":[{"name":"diary","slug":"diary","permalink":"http://example.com/categories/diary/"}],"tags":[]},{"title":"习题之一元一次方程","slug":"习题之一元一次方程","date":"2021-07-19T18:43:58.000Z","updated":"2021-07-19T21:40:59.227Z","comments":true,"path":"2021/07/20/习题之一元一次方程/","link":"","permalink":"http://example.com/2021/07/20/%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%B8%80%E5%85%83%E4%B8%80%E6%AC%A1%E6%96%B9%E7%A8%8B/","excerpt":"问题背景：实现一元一次方程的计算，例如：input：3a+3=9output:a=2 note:给出的一元一次方程中没有括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 20-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 20-Jul-2021 */#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define MAX_COEF_LEN 10#define MAX_COEFARR_LEN 16#define INPUT_IS_SYMBOL(input) ((input == &#x27;-&#x27;) || (input == &#x27;+&#x27;) || (input == &#x27;=&#x27;))#define INPUT_IS_NUM(input) ((input &lt;= 9) &amp;&amp; (input &gt;= 0))#define TEMPTERM_IS_INITSTAT(pTermTemp) ((pTermTemp-&gt;sym == positive) &amp;&amp; (pTermTemp-&gt;coef[pTermTemp-&gt;curCoefarrPos] == 1) &amp;&amp; (pTermTemp-&gt;curCoefarrPos == 0))enum symbol&#123; negtive = -1, positive = 1&#125;;typedef struct term&#123; enum symbol sym; int symStat; char curPos; int coefArr[MAX_COEFARR_LEN];&#125; term;void UpdateCurCoef(term *term, int *coef)&#123; int temp; for(int loop = 0; loop &lt; term-&gt;curPos; loop++) &#123; temp += term-&gt;coefArr[term-&gt;curPos - loop] * pow(10, loop); &#125; *coef += term-&gt;sym * temp; return;&#125;void IniTempterm(term* tempTerm)&#123; tempTerm-&gt;sym = positive; tempTerm-&gt;symStat = 1; tempTerm-&gt;curPos = 0; tempTerm-&gt;coefArr[tempTerm-&gt;curPos] = 1;&#125;int main()&#123; int leftCoef, rightCoef; int *curCoef = &amp;rightCoef; term tempTerm; IniTempterm(&amp;tempTerm); char input; char unknownNum; scanf(&quot;%c&quot;, &amp;input); while(input != &#x27;\\0&#x27;) &#123; if(INPUT_IS_SYMBOL(input)) &#123; switch(input) &#123; UpdateCurCoef(&amp;tempTerm, curCoef); curCoef = &amp;rightCoef; IniTempterm(&amp;tempTerm); case &#x27;+&#x27;: tempTerm.sym = 1 * tempTerm.symStat; case &#x27;-&#x27;: tempTerm.sym = -1 * tempTerm.symStat; case &#x27;=&#x27;: tempTerm.symStat = -1; default: &#123; printf(&quot;input err\\n&quot;); return 0; &#125; &#125; &#125; else if(INPUT_IS_NUM(input)) &#123; tempTerm.coefArr[tempTerm.curPos] = input; tempTerm.curPos++; &#125; else &#123; unknownNum = input; curCoef = &amp;leftCoef; &#125; &#125; printf(&quot;%c=%d\\n&quot;, unknownNum, -(rightCoef/leftCoef)); return 0;&#125;","text":"问题背景：实现一元一次方程的计算，例如：input：3a+3=9output:a=2 note:给出的一元一次方程中没有括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * @Author: Nonrustknife &lt;chris&gt; * @Date: 20-Jul-2021 * @Email: cm656879@outlook.com * @Last modified by: chris * @Last modified time: 20-Jul-2021 */#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define MAX_COEF_LEN 10#define MAX_COEFARR_LEN 16#define INPUT_IS_SYMBOL(input) ((input == &#x27;-&#x27;) || (input == &#x27;+&#x27;) || (input == &#x27;=&#x27;))#define INPUT_IS_NUM(input) ((input &lt;= 9) &amp;&amp; (input &gt;= 0))#define TEMPTERM_IS_INITSTAT(pTermTemp) ((pTermTemp-&gt;sym == positive) &amp;&amp; (pTermTemp-&gt;coef[pTermTemp-&gt;curCoefarrPos] == 1) &amp;&amp; (pTermTemp-&gt;curCoefarrPos == 0))enum symbol&#123; negtive = -1, positive = 1&#125;;typedef struct term&#123; enum symbol sym; int symStat; char curPos; int coefArr[MAX_COEFARR_LEN];&#125; term;void UpdateCurCoef(term *term, int *coef)&#123; int temp; for(int loop = 0; loop &lt; term-&gt;curPos; loop++) &#123; temp += term-&gt;coefArr[term-&gt;curPos - loop] * pow(10, loop); &#125; *coef += term-&gt;sym * temp; return;&#125;void IniTempterm(term* tempTerm)&#123; tempTerm-&gt;sym = positive; tempTerm-&gt;symStat = 1; tempTerm-&gt;curPos = 0; tempTerm-&gt;coefArr[tempTerm-&gt;curPos] = 1;&#125;int main()&#123; int leftCoef, rightCoef; int *curCoef = &amp;rightCoef; term tempTerm; IniTempterm(&amp;tempTerm); char input; char unknownNum; scanf(&quot;%c&quot;, &amp;input); while(input != &#x27;\\0&#x27;) &#123; if(INPUT_IS_SYMBOL(input)) &#123; switch(input) &#123; UpdateCurCoef(&amp;tempTerm, curCoef); curCoef = &amp;rightCoef; IniTempterm(&amp;tempTerm); case &#x27;+&#x27;: tempTerm.sym = 1 * tempTerm.symStat; case &#x27;-&#x27;: tempTerm.sym = -1 * tempTerm.symStat; case &#x27;=&#x27;: tempTerm.symStat = -1; default: &#123; printf(&quot;input err\\n&quot;); return 0; &#125; &#125; &#125; else if(INPUT_IS_NUM(input)) &#123; tempTerm.coefArr[tempTerm.curPos] = input; tempTerm.curPos++; &#125; else &#123; unknownNum = input; curCoef = &amp;leftCoef; &#125; &#125; printf(&quot;%c=%d\\n&quot;, unknownNum, -(rightCoef/leftCoef)); return 0;&#125;","categories":[{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"添加封面图片","slug":"添加封面图片","date":"2021-06-27T11:06:58.000Z","updated":"2021-07-04T09:28:13.952Z","comments":true,"path":"2021/06/27/添加封面图片/","link":"","permalink":"http://example.com/2021/06/27/%E6%B7%BB%E5%8A%A0%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87/","excerpt":"","text":"","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"HELLO WORLD","slug":"hello-world","date":"2021-06-26T05:01:37.141Z","updated":"2021-07-04T09:17:45.955Z","comments":true,"path":"2021/06/26/hello-world/","link":"","permalink":"http://example.com/2021/06/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"手把手教你写Makefile和CMakelists.txt","slug":"欢迎来到我的网络世界","date":"2021-06-25T15:22:55.000Z","updated":"2021-06-29T13:42:53.367Z","comments":true,"path":"2021/06/25/欢迎来到我的网络世界/","link":"","permalink":"http://example.com/2021/06/25/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C/","excerpt":"入职后开始接触了Linux环境下的代码，而且是一个代码量10W+的巨型工程，刚面对这样打的项目时总是对其中重重的文件目录感到惊讶，这么多的文件是怎么变成最后的可执行文件的？ 之前在学校或者个人学习的时候写的代码都是比较简单的，一个目录下若干个c文件，编译时直接使用gcc工具一步执行gcc main.c -o main就完事了，但是面对这种多目录多源文件的项目如果还使用这种方法的话明显生产效率是极低的。由于不同的项目在进行编译时都使用相同的编译指令，只是路径和文件名不同，所以自然想到应该可以编写脚本实现编译自动化，经过学习发现原来有一种专门的脚本语言用来解决这件事，就是今天学习的内容Makefile和CMakelists.txt。 什么是Makefile首先说下Makefile，Makefile就是包含编译指令的一个脚本，Makefile需要和make搭配使用，make是Linux平台下的一个工具，通过它可以执行Makefile中的编译指令以完成工程的编译。make和Makefile的关系可以用bash和shell脚本做类比，脚本中按照脚本的规定语法写好了一些指令，然后通过对应的执行命令将脚本中的一系列指令执行完成。 接下来我们就来看下书写Makefile脚本的语法规则吧，首先我们都知道生成一个可执行文件需要有源文件，而源文件多数也都需要依赖文件，例如头文件等，Makefile中也必须遵循这样的原则。 makefile的语法规则之一就是：(以C语言项目为例，使用GCC工具，如果是C++项目则使用G++工具) targetFile:sourceFilegcc -[E][S][C][ ] sourceFile -o targetFile # gcc -E 表示只进行预编译，得到的目标文件为后缀为i的预编译文件（预编译执行的操作包括头展开，宏替换以及条件编译优化） # gcc -S 表示进行预编译和汇编，得到后缀为s的汇编文件（汇编将预编译的代码转换为汇编代码）","text":"入职后开始接触了Linux环境下的代码，而且是一个代码量10W+的巨型工程，刚面对这样打的项目时总是对其中重重的文件目录感到惊讶，这么多的文件是怎么变成最后的可执行文件的？ 之前在学校或者个人学习的时候写的代码都是比较简单的，一个目录下若干个c文件，编译时直接使用gcc工具一步执行gcc main.c -o main就完事了，但是面对这种多目录多源文件的项目如果还使用这种方法的话明显生产效率是极低的。由于不同的项目在进行编译时都使用相同的编译指令，只是路径和文件名不同，所以自然想到应该可以编写脚本实现编译自动化，经过学习发现原来有一种专门的脚本语言用来解决这件事，就是今天学习的内容Makefile和CMakelists.txt。 什么是Makefile首先说下Makefile，Makefile就是包含编译指令的一个脚本，Makefile需要和make搭配使用，make是Linux平台下的一个工具，通过它可以执行Makefile中的编译指令以完成工程的编译。make和Makefile的关系可以用bash和shell脚本做类比，脚本中按照脚本的规定语法写好了一些指令，然后通过对应的执行命令将脚本中的一系列指令执行完成。 接下来我们就来看下书写Makefile脚本的语法规则吧，首先我们都知道生成一个可执行文件需要有源文件，而源文件多数也都需要依赖文件，例如头文件等，Makefile中也必须遵循这样的原则。 makefile的语法规则之一就是：(以C语言项目为例，使用GCC工具，如果是C++项目则使用G++工具) targetFile:sourceFilegcc -[E][S][C][ ] sourceFile -o targetFile # gcc -E 表示只进行预编译，得到的目标文件为后缀为i的预编译文件（预编译执行的操作包括头展开，宏替换以及条件编译优化） # gcc -S 表示进行预编译和汇编，得到后缀为s的汇编文件（汇编将预编译的代码转换为汇编代码） # gcc -c 表示进行预编译、汇编和编译，得到后缀为o的二进制文件（编译将汇编代码转换为二进制机器语言） # gcc不带参数表示直接进行预编译、汇编、编译和链接，得到可执行文件 其中第一行定义了目标文件和源文件，中间用冒号隔开，第二行先用TAB键置空位，然后给出了具体的实现指令。 该命令只有在目标文件不存在，或目标比依赖的文件更旧，才会被执行。 当我们的工程中在同一目录下出现了多个C源文件时，则需重复上面两行指令依次生成.o文件最后链接成可执行文件。那么为了减少这种重复度极高的代码的书写，makefile语法中提供了一种设置替换的方式，可以将所有的同类型文件用一个变量来表示。 OBJ=a.o b.o c.o TAR=main 这样Makefile中所有出现a.o b.o c.o的地方就都可以用$(OBJ)来代替，所有出现main的地方都可以用$(TAR)表示，$(变量名)为变量的使用方式。 另外还可以用+=进行追加使变量可以适用于不同的场景。:=则表示恒等于，使用恒等于设置的变量就不能在进行追加了。 除此以外，还有一些固定变量，**%.c表示任意的.c文件，%.o表示任意的.o文件， .c表示所有的.c文件，.o表示所有的.o文件，$@表示所有的目标文件，$^表示所有的依赖文件，$&lt;表示所有依赖文件的第一个**。 通过这些变量使得我们的Makefile大大精简，同时还增强了Makefile在不同工程下的适用性。 最后在Makefile文件中还会集成一些和编译无关的操作我们希望在进行编译时或之前或之后同时进行的，例如编译之前先清除遗留的中间文件而重新生成覆盖，Makefile同样提供了一种伪目标的方式来实现。 .PHONY:clear clear: rm -rf main.o main .PHONY后面的target（即冒号之前的文件）表示的也是一个伪造的target, 而不是真实存在的文件target 总结一下，Makefile的编写其实就包括三步，第一步，指定目标文件和依赖文件；第二步，给出从依赖文件到目标文件的实现指令；第三步，进行变量替换； 华丽的分割线 CMakelists.txt又是什么东西?因为不同平台下的Makefile书写规则是不一样的，Makefile只适用于类UNIX系统下的编译，如果是在Windows环境下则需要重新编写Makefile。cmake就是为了解决跨平台编译的问题，使用cmake工具，可以自动生成适应平台的Makefile。 同样的，在单目录的场景下，CMakelists.txt的语法如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) AUX_SOURCE_DIR(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) 只需要三行代码，第一行指定支持的cmake最低版本；第二行给工程命名；第三行将目录下所有源文件打包成变量，第四行生成可执行文件； 如果是多目录下，比如一个库文件目录和一个源文件目录的话，则需要在每个目录下面都编写一个CMakeLists.txt，一共三个，分别是源文件目录，库文件目录和根目录 其中源文件目录src下的CMakeListx.txt内容如下 AUX_SOURCE_DIRECTORY(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) TARGET_LINK_LIBRARIES(main mylib) 库文件目录mylib下面的CMakeLists.txt内容如下 AUX_SOURCE_DIRECTORY(./ DIR_LIB) ADD_LIBRARY(mylib ${DIR_LIB}) 根目录下的CMakeLists.txt内容如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) ADD_SUBDIRECTORY(./src) ADD_SUBDIRECTORY(./mylib) 这是库目录和源文件目录分离的场景，如果说只有一个源文件没必要新建一个源文件目录即不存在源文件目录的情况下，库目录下的CMakeLists.txt不变，根目录下的CMakeLists.txt内容如下 CMAKE_MINIMUM_REQUIRED(3.10) PROJECT(main) ADD_SUBDIRECTORY(./mylib) AUX_SOURCE_DIRECTORY(./ DIR_SRC) ADD_EXECUTABLE(main ${DIR_SRC}) TARGET_LINK_LIBRARIES(main mylib) 实际上就是把原来根目录和源文件目录下的CMakeLists.txt合并了 以上是自己学习CMake的一点学习记录，总结下来发现也完全不难，只需要理解两个场景单目录和多目录下的编写方式就可以了，关键的语法不超过10行，CMake的知识点还有很多，具体详情可以在网上搜索。总之，CMake可以让我们不用去编写复杂的Makefile，并且跨平台，是个非常强大并值得一学的工具。 如果有写的不对的地方，希望能留言指正，谢谢阅读。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"编译技术","slug":"编译技术","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"}]}],"categories":[{"name":"diary","slug":"diary","permalink":"http://example.com/categories/diary/"},{"name":"习题","slug":"习题","permalink":"http://example.com/categories/%E4%B9%A0%E9%A2%98/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"编译技术","slug":"编译技术","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"}]}